<predicates-set>
  <predicates>
    <simple-predicate>
      <title>Predicates for list management</title>
      <description>These predicates are used for managing lists of elements</description>
      <predicates>/* Generates a sublist (SUB) from a list (L) */&#xd;
&#xd;
sublist(L,SUB):-&#xd;
    append(AUX,_,L),&#xd;
    append(_,SUB,AUX).&#xd;
&#xd;
/* The first and the last element of given list */&#xd;
&#xd;
first([FIRST|COLA],FIRST).&#xd;
&#xd;
last([LAST],LAST).&#xd;
&#xd;
last([NO_LAST|COLA],LAST):-&#xd;
	last(COLA,LAST).&#xd;
&#xd;
/* Generate a new list from two lists */&#xd;
/* The new list contains all the elements of the two given lists, but without repeated elements */&#xd;
&#xd;
append_set([],X,X):- !.&#xd;
&#xd;
append_set(X,[],X):- !.&#xd;
&#xd;
append_set(L,[X|COLA],NEWL):-&#xd;
	member(X,L),&#xd;
	append_set(L,COLA,NEWL),&#xd;
	!.&#xd;
&#xd;
append_set(L,[X|COLA],NEWL):-&#xd;
	append(L,[X],L2),&#xd;
	append_set(L2,COLA,NEWL),&#xd;
	!.</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Java operators</title>
      <description>Determine the type of operator given its code</description>
      <predicates>/* Airthmetic */&#xd;
&#xd;
arithmetic_operator(&apos;PLUS&apos;).&#xd;
arithmetic_operator(&apos;MINUS&apos;).&#xd;
arithmetic_operator(&apos;TIMES&apos;).&#xd;
arithmetic_operator(&apos;DIVIDE&apos;).&#xd;
arithmetic_operator(&apos;REMAINDER&apos;).&#xd;
&#xd;
/* Comparision */&#xd;
&#xd;
comparision_operator(&apos;EQUALS&apos;).&#xd;
comparision_operator(&apos;NOT_EQUALS&apos;).&#xd;
comparision_operator(&apos;GREATER&apos;).&#xd;
comparision_operator(&apos;LESS_EQUALS&apos;).&#xd;
comparision_operator(&apos;LESS&apos;).&#xd;
comparision_operator(&apos;GREATER_EQUALS&apos;).&#xd;
&#xd;
/* Bits */&#xd;
&#xd;
bit_operator(&apos;COMPLEMENT&apos;).&#xd;
bit_operator(&apos;LEFT_SHIFT&apos;).&#xd;
bit_operator(&apos;RIGHT_SHIFT_SIGNED&apos;).&#xd;
bit_operator(&apos;RIGHT_SHIFT_UNSIGNED&apos;).&#xd;
bit_operator(&apos;BIT_AND_ASSIGN&apos;).&#xd;
bit_operator(&apos;XOR&apos;).&#xd;
bit_operator(&apos;BIT_OR_ASSIGN&apos;).&#xd;
bit_operator(&apos;AND&apos;).&#xd;
bit_operator(&apos;OR&apos;).&#xd;
bit_operator(&apos;CONDITIONAL_AND&apos;).&#xd;
bit_operator(&apos;CONDITIONAL_OR&apos;).&#xd;
bit_operator(&apos;NOT&apos;).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Collection types</title>
      <description>Check if the given type is an array or a predefined Collection types from Java (a List, a Map or a Set)</description>
      <predicates>/* Check if the type is a collection type */&#xd;
/* i.e, an array, or a Java collection type (a list, a map, a set, etc.). */&#xd;
&#xd;
collection_type(ID):-&#xd;
	(&#xd;
		array_type(ID,_, _);&#xd;
		java_collection_type(ID)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
/* Java Collections */&#xd;
&#xd;
java_collection_type(ID):-&#xd;
	(&#xd;
		list_type(ID);&#xd;
		map_type(ID);&#xd;
		set_type(ID)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
/* Java list types*/&#xd;
&#xd;
list_type(TYPE):-&#xd;
	(&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.Vector&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.ArrayList&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.AbstractList&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.AbstractSequentialList&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.concurrent.CopyOnWriteArrayList&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.LinkedList&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.List&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.Stack&apos;), _)&#xd;
	),&#xd;
	!.&#xd;
&#xd;
list_type(TYPE):-&#xd;
	(&#xd;
		type(TYPE, name(&apos;Vector&apos;));&#xd;
		type(TYPE, name(&apos;List&apos;));&#xd;
		type(TYPE, name(&apos;ArrayList&apos;));&#xd;
		type(TYPE, name(&apos;AbstractList&apos;));&#xd;
		type(TYPE, name(&apos;AbstractSequentialList&apos;));&#xd;
		type(TYPE, name(&apos;Stack&apos;));&#xd;
		type(TYPE, name(&apos;LinkedList&apos;));&#xd;
		type(TYPE, name(&apos;CopyOnWriteArrayList&apos;))&#xd;
	),&#xd;
	!.&#xd;
&#xd;
/* Java map types */&#xd;
&#xd;
map_type(TYPE):-&#xd;
	(&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.WeakHashMap&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.AbstractMap&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.Map&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.concurrent.ConcurrentHashMap&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.concurrent.ConcurrentSkipListMap&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.HashMap&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.Hashtable&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.IdentityHashMap&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.LinkedHashMap&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.TreeMap&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.EnumMap&apos;), _)&#xd;
	),&#xd;
	!.&#xd;
&#xd;
map_type(TYPE):-&#xd;
	(&#xd;
		type(TYPE, name(&apos;WeakHashMap&apos;));&#xd;
		type(TYPE, name(&apos;AbstractMap&apos;));&#xd;
		type(TYPE, name(&apos;Map&apos;));&#xd;
		type(TYPE, name(&apos;ConcurrentHashMap&apos;));&#xd;
		type(TYPE, name(&apos;ConcurrentSkipListMap&apos;));&#xd;
		type(TYPE, name(&apos;HashMap&apos;));&#xd;
		type(TYPE, name(&apos;Hashtable&apos;));&#xd;
		type(TYPE, name(&apos;IdentityHashMap&apos;));&#xd;
		type(TYPE, name(&apos;LinkedHashMap&apos;));&#xd;
		type(TYPE, name(&apos;TreeMap&apos;));&#xd;
		type(TYPE, name(&apos;EnumMap&apos;))&#xd;
	),&#xd;
	!.&#xd;
&#xd;
/* Java set types */&#xd;
&#xd;
set_type(TYPE):-&#xd;
    (&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.AbstractSet&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.Set&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.concurrent.ConcurrentSkipListSet&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.concurrent.CopyOnWriteArraySet&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.HashSet&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;javax.print.attribute.standard.JobStateReasons&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.LinkedHashSet&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.TreeSet&apos;), _);&#xd;
	    parameterized_type(TYPE, fqn(&apos;java.util.EnumSet&apos;), _)&#xd;
	),&#xd;
	!.&#xd;
&#xd;
set_type(TYPE):-&#xd;
	(&#xd;
		type(TYPE, name(&apos;AbstractSet&apos;));&#xd;
		type(TYPE, name(&apos;Set&apos;));&#xd;
		type(TYPE, name(&apos;ConcurrentSkipListSet&apos;));&#xd;
		type(TYPE, name(&apos;CopyOnWriteArraySet&apos;));&#xd;
		type(TYPE, name(&apos;HashSet&apos;));&#xd;
		type(TYPE, name(&apos;JobStateReasons&apos;));&#xd;
		type(TYPE, name(&apos;LinkedHashSet&apos;));&#xd;
		type(TYPE, name(&apos;TreeSet&apos;));&#xd;
		type(TYPE, name(&apos;EnumSet&apos;))&#xd;
	),&#xd;
	!.</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Plain types</title>
      <description>A list with all the types that compose an specified type</description>
      <predicates>/* List the types that compose an specified type */&#xd;
/* For example, the type Vector&lt;ArrayList&lt;String&gt;&gt; will list [Vector,ArrayList,String] */&#xd;
&#xd;
plain_types([],[]):- !.&#xd;
&#xd;
plain_types(ID,[ID]):-&#xd;
	(&#xd;
		class_declaration(ID, _, _, _, _, _, _, _, _, _, _);&#xd;
		interface_declaration(ID, _, _, _, _, _, _, _, _, _);&#xd;
		enum_declaration(ID, _, _, _, _, _, _, _)&#xd;
	),&#xd;
	!.&#xd;
&#xd;
plain_types(ID,[ID]):-&#xd;
    primitive_type(ID, _),&#xd;
    !.&#xd;
&#xd;
plain_types(ID,[ID]):-&#xd;
    type(ID, _),&#xd;
    !.&#xd;
&#xd;
plain_types(ID,LIST):-&#xd;
    array_type(ID, array_of(AO), _),&#xd;
    plain_types(AO,LIST),&#xd;
    !.&#xd;
&#xd;
plain_types(ID,LIST):-&#xd;
	parameterized_type(ID, _, parameters(PARAMETERS)),&#xd;
    plain_types(PARAMETERS,LIST),&#xd;
    !.&#xd;
&#xd;
plain_types(ID,LIST):-&#xd;
    (&#xd;
        union_type(ID, types(TYPE));&#xd;
        intersection_type(ID, types(TYPE))&#xd;
    ),&#xd;
    plain_types(TYPE,LIST),&#xd;
    !.&#xd;
&#xd;
plain_types([X|COLA],LIST):-&#xd;
    plain_types(X,LIST_X),&#xd;
    plain_types(COLA,LIST_COLA),&#xd;
    append_set(LIST_X,LIST_COLA,LIST),&#xd;
    !.</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Methods (modifiers)</title>
      <description>Check if a method fills some characteristics (like if the method is public, or private, or protected, etc.)</description>
      <predicates>/* Check if a method is a public method, or returns a public method if ID is not specified */&#xd;
&#xd;
public_method(ID):-&#xd;
    (&#xd;
        method_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _);&#xd;
        constructor_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _)&#xd;
    ),&#xd;
    member(&apos;public&apos;, MODIFIERS).&#xd;
&#xd;
/* Check if a method is a protected method, or returns a protected method if ID is not specified */&#xd;
&#xd;
protected_method(ID):-&#xd;
    (&#xd;
        method_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _);&#xd;
        constructor_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _)&#xd;
    ),&#xd;
    member(&apos;protected&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a method is a private method, or returns a private method if ID is not specified */&#xd;
&#xd;
private_method(ID):-&#xd;
    (&#xd;
        method_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _);&#xd;
        constructor_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _)&#xd;
    ),&#xd;
    member(&apos;private&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a method is a static method, or returns a static method if ID is not specified */&#xd;
&#xd;
static_method(ID):-&#xd;
    (&#xd;
        method_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _);&#xd;
        constructor_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _)&#xd;
    ),&#xd;
    member(&apos;static&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a method is an abstract method, or returns an abstract method if ID is not specified */&#xd;
&#xd;
abstract_method(ID):-&#xd;
    (&#xd;
        method_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _);&#xd;
        constructor_declaration(ID, _, _, modifiers(MODIFIERS), _, _, _, _, _, _, _)&#xd;
    ),&#xd;
    member(&apos;abstract&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a method is a package method, or returns a package method if ID is not specified */&#xd;
&#xd;
package_method(ID):-&#xd;
    (&#xd;
        method_declaration(ID, _, _, _, _, _, _, _, _, _, _);&#xd;
        constructor_declaration(ID, _, _, _, _, _, _, _, _, _, _)&#xd;
    ),&#xd;
    not(public_method(ID)),&#xd;
    not(protected_method(ID)),&#xd;
    not(private_method(ID)).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Fields (modifiers)</title>
      <description>Check if a field fills some characteristics (like if the field is public, or private, or protected, etc.)</description>
      <predicates>/* Check if a field is a public field or returns a public field if ID is not specified */&#xd;
&#xd;
public_field(ID):-&#xd;
    field_declaration(ID, _, _, _, modifiers(MODIFIERS), _, _, _),&#xd;
    member(&apos;public&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a field is a protected field or returns a protected field if ID is not specified */&#xd;
&#xd;
protected_field(ID):-&#xd;
    field_declaration(ID, _, _, _, modifiers(MODIFIERS), _, _, _),&#xd;
    member(&apos;protected&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a field is a private field or returns a private field if ID is not specified */&#xd;
&#xd;
private_field(ID):-&#xd;
	field_declaration(ID, _, _, _, modifiers(MODIFIERS), _, _, _),&#xd;
    member(&apos;private&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a field is a static field or returns a static field if ID is not specified */&#xd;
&#xd;
static_field(ID):-&#xd;
    field_declaration(ID, _, _, _, modifiers(MODIFIERS), _, _, _),&#xd;
    member(&apos;static&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a field is a final field or returns a final field if ID is not specified */&#xd;
&#xd;
final_field(ID):-&#xd;
	field_declaration(ID, _, _, _, modifiers(MODIFIERS), _, _, _),&#xd;
    member(&apos;final&apos;,MODIFIERS).&#xd;
&#xd;
/* Check if a field is a package field or returns a package field if ID is not specified */&#xd;
&#xd;
package_field(ID):-&#xd;
    field_declaration(ID, _, _, _, _, _, _, _),&#xd;
    not(public_field(ID)),&#xd;
    not(protected_field(ID)),&#xd;
    not(private_field(ID)).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Similar codes</title>
      <description>Check if two codes are similar</description>
      <predicates>/* Check if two list of statements are similar */&#xd;
/* This predicate is long and tedious, please, read it meticulously before doing any change*/&#xd;
/* It is a good idea to always have a backup of the original predicate */&#xd;
&#xd;
similar_code([],[]):- !.&#xd;
&#xd;
similar_code([X|COLA],[X|COLA2]):-&#xd;
    !,&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([null|COLA],COLA2):-&#xd;
    !,&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code(COLA,[null|COLA2]):-&#xd;
    !,&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],Y):-&#xd;
    X \= Y,&#xd;
    cast_expression(X, _, _, expression(E), _, _, _),&#xd;
    !,&#xd;
    similar_code([E|COLA],Y).&#xd;
 &#xd;
similar_code(Y,[X|COLA]):-&#xd;
    X \= Y,&#xd;
    cast_expression(X, _, _, expression(E), _, _, _),&#xd;
    !,&#xd;
    similar_code(Y,[E|COLA]).&#xd;
   &#xd;
similar_code([X|COLA],Y):-&#xd;
    X \= Y,&#xd;
    (&#xd;
        array_initializer(X, _, _, _, _, _);&#xd;
        assert_statement(X, _, _, _, _, _, _);&#xd;
        this_expression(X, _, _, _, _, _);&#xd;
        throw_statement(X, _, _, _, _, _);&#xd;
        empty_statement(X, _, _, _, _);&#xd;
        break_statement(X, _, _, _, _, _);&#xd;
        continue_statement(X, _, _, _, _, _)&#xd;
    ), &#xd;
    !,&#xd;
    similar_code(COLA,Y).&#xd;
&#xd;
similar_code(Y,[X|COLA]):-&#xd;
    X \= Y,&#xd;
    (&#xd;
        array_initializer(X, _, _, _, _, _);&#xd;
        assert_statement(X, _, _, _, _, _, _);&#xd;
        this_expression(X, _, _, _, _, _);&#xd;
        throw_statement(X, _, _, _, _, _);&#xd;
        empty_statement(X, _, _, _, _);&#xd;
        break_statement(X, _, _, _, _, _);&#xd;
        continue_statement(X, _, _, _, _, _)&#xd;
    ), &#xd;
    !,&#xd;
    similar_code(Y,COLA).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    (&#xd;
        (&#xd;
            boolean_literal(X, _, _, _, _, _);&#xd;
            character_literal(X, _, _, _, _, _);&#xd;
            number_literal(X, _, _, _, _, _);&#xd;
            string_literal(X, _, _, _, _, _);&#xd;
            type_literal(X,_, _, _, _, _);&#xd;
            null_literal(X, _, _, _, _)&#xd;
        ),&#xd;
        (&#xd;
            boolean_literal(Y, _, _, _, _, _);&#xd;
            character_literal(Y, _, _, _, _, _);&#xd;
            number_literal(Y, _, _, _, _, _);&#xd;
            string_literal(Y, _, _, _, _, _);&#xd;
            type_literal(Y,_, _, _, _, _);&#xd;
            null_literal(Y, _, _, _, _)&#xd;
        )&#xd;
    ),&#xd;
    !,&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    anonymous_class_declaration(X, _, declarations(L1), _),&#xd;
    anonymous_class_declaration(Y, _, declarations(L2), _),&#xd;
    !,&#xd;
    append(L1,COLA,NEWCOLA),&#xd;
    append(L2,COLA2,NEWCOLA2),&#xd;
    similar_code(NEWCOLA,NEWCOLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    array_access(X, _, array(A1), index(I1), _, _, _),&#xd;
    array_access(Y, _, array(A2), index(I2), _, _, _),&#xd;
    !,&#xd;
    similar_code([A1,I1|COLA],[A2,I2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    array_creation(X, _, type(T1), dimensions(D), _, _, _, _),&#xd;
    array_creation(Y, _, type(T2), dimensions(D), _, _, _, _),&#xd;
    !,&#xd;
    similar_type(T1,T2),&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    assignment(X, _, operator(O), left_operand(LO1), right_operand(RO1), _, _, _),&#xd;
    assignment(Y, _, operator(O), left_operand(LO2), right_operand(RO2), _, _, _),&#xd;
    !,&#xd;
    similar_code([LO1,RO1|COLA],[LO2,RO2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    block(X, _, statements(S1), _, _, _),&#xd;
    block(Y, _, statements(S2), _, _, _),&#xd;
    !,&#xd;
    append(S1,COLA,NUEVACOLA),&#xd;
    append(S2,COLA2,NUEVACOLA2),&#xd;
    similar_code(NUEVACOLA,NUEVACOLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    catch_clause(X, _, exception(E1), body(B1), _, _, _),&#xd;
    catch_clause(Y, _, exception(E2), body(B2), _, _, _),&#xd;
    !,&#xd;
    similar_code([B1|COLA],[B2|COLA2]).&#xd;
 &#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    class_instance_creation(X, _, type(T1), _, _, _, _, _),&#xd;
    class_instance_creation(Y, _, type(T2), _, _, _, _, _),&#xd;
    !,&#xd;
    similar_type(T1,T2),&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    conditional_expression(X, _, condition(C1), then(T1), else(E1), _, _, _),&#xd;
    conditional_expression(Y, _, condition(C2), then(T2), else(E2), _, _, _),  &#xd;
    !,&#xd;
    similar_code([C1,T1,E1|COLA],[C2,T2,E2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    constructor_invocation(X, _, _, constructor(C1), _, _, _, _),&#xd;
    constructor_invocation(Y, _, _, constructor(C2), _, _, _, _),&#xd;
    !,&#xd;
    (&#xd;
        C1 = null;&#xd;
        (&#xd;
            C1 \= null,&#xd;
            C2 = null&#xd;
        );&#xd;
        (&#xd;
            constructor_declaration(C1, parent(T1), _, _, _, _, _, _, _, _, _),&#xd;
            constructor_declaration(C2, parent(T2), _, _, _, _, _, _, _, _, _),&#xd;
            similar_type(T1,T2)&#xd;
        )&#xd;
    ),&#xd;
    similar_code(NEWCOLA,NEWCOLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    creation_reference(X, _, type(T1), _, _, _, _, _),&#xd;
    creation_reference(Y, _, type(T2), _, _, _, _, _),&#xd;
    !,&#xd;
    similar_type(T1,T2),&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    do_statement(X, _, expression(E1), body(B1), _, _, _),&#xd;
    do_statement(Y, _, expression(E2), body(B2), _, _, _),&#xd;
    !,&#xd;
    similar_code([E1,B1|COLA],[E2,B2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    enhanced_for_statement(X, _, parameter(P1), expression(E1), body(B1), _, _),&#xd;
    enhanced_for_statement(Y, _, parameter(P2), expression(E2), body(B2), _, _),&#xd;
    similar_code([P1,E1,B1|COLA],[P2,E2,B2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    enum_constant_declaration(X, parent(P), _, _, _, _, _),&#xd;
    enum_constant_declaration(Y, parent(P), _, _, _, _, _),&#xd;
    !,&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    expression_method_reference(X, _, expression(E1), method(M1), _, _, _, _),&#xd;
    expression_method_reference(Y, _, expression(E2), method(M2), _, _, _, _),&#xd;
    !,&#xd;
    similar_method(M1,M2),&#xd;
    similar_code([E1|COLA],[E2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    field_access(X, _, expression(E1), field(F1), _, _, _),&#xd;
    field_access(Y, _, expression(E2), field(F2), _, _, _),&#xd;
    !,&#xd;
    similar_code([E1,F1|COLA],[E2,F2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    field_declaration(X, parent(P1), _, type(T1), _, extra_dimensions(D), _, _),&#xd;
    field_declaration(Y, parent(P2), _, type(T2), _, extra_dimensions(D), _, _),&#xd;
    !,&#xd;
    P1 \= P2,&#xd;
    similar_type(T1,T2),&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    for_statement(X, _, initializers(I1), expression(E1), updaters(U1), body(B1), _, _, _),&#xd;
    for_statement(Y, _, initializers(I2), expression(E2), updaters(U2), body(B2), _, _, _),&#xd;
    !,&#xd;
    append(I1,U1,L1),&#xd;
    append(I2,U2,L2),&#xd;
    append(L1,COLA,NEWCOLA),&#xd;
    append(L2,COLA2,NEWCOLA2),&#xd;
    similar_code([E1,B1|NEWCOLA],[E2,B2|NEWCOLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    if_statement(X, _, condition(C1), then(T1), else(E1), _, _, _),&#xd;
    if_statement(Y, _, condition(C2), then(T2), else(E2), _, _, _),&#xd;
    !,&#xd;
    similar_code([C1,T1,E1|COLA],[C2,T2,E2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    instanceof_expression(X, _, expression(E1), type(T1), _, _, _),&#xd;
    instanceof_expression(Y, _, expression(E2), type(T2), _, _, _),&#xd;
    !,&#xd;
    similar_type(T1,T2),&#xd;
    similar_code([E1|COLA],[E2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    infix_expression(X, _, operator(O), left_operand(LO1), right_operand(RO1), extended_operands(L1), _, _, _),&#xd;
    infix_expression(Y, _, operator(O), left_operand(LO2), right_operand(RO2), extended_operands(L2), _, _, _),&#xd;
    !,&#xd;
    append(L1,COLA,NEWCOLA),&#xd;
    append(L2,COLA2,NEWCOLA2),&#xd;
    similar_code([LO1,RO1|NEWCOLA],[LO2,RO2|NEWCOLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    labeled_statement(X, _, parameters(L1), body(B1), _, _, _),&#xd;
    labeled_statement(Y, _, parameters(L2), body(B2), _, _, _),&#xd;
    !,&#xd;
    append(L1,COLA,NEWCOLA),&#xd;
    append(L2,COLA2,NEWCOLA2),&#xd;
    similar_code([B1|NEWCOLA],[B2|NEWCOLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    lambda_expression(X, _, parameters(P1), body(B1), _, _),&#xd;
    lambda_expression(Y, _, parameters(P2), body(B2), _, _),&#xd;
    !,&#xd;
    append(P1,[B1|COLA],NEWCOLA),&#xd;
    append(P2,[B2|COLA2],NEWCOLA2),&#xd;
    similar_code(NEWCOLA,NEWCOLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    method_invocation(X, _, expression(E1), method(M1), arguments(A1), _, _, _),&#xd;
    method_invocation(Y, _, expression(E2), method(M2), arguments(A2), _, _, _),&#xd;
    !,&#xd;
    similar_method(M1,M2),&#xd;
    append(A1,[E1|COLA],NEWCOLA),&#xd;
    append(A2,[E2|COLA2],NEWCOLA2),&#xd;
    similar_code(NEWCOLA,NEWCOLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    postfix_expression(X, _, operator(O), operand(O1), _, _, _),&#xd;
    postfix_expression(Y, _, operator(O), operand(O2), _, _, _),&#xd;
    !,&#xd;
    similar_code([O1|COLA],[O2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    prefix_expression(X, _, operator(O), operand(O1), _, _, _),&#xd;
    prefix_expression(Y, _, operator(O), operand(O2), _, _, _),&#xd;
    !,&#xd;
    similar_code([O1|COLA],[O2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    qualified_name(X, _, qualified(Q1), name(N1), _, _, _),&#xd;
    qualified_name(Y, _, qualified(Q2), name(N2), _, _, _),&#xd;
    !,&#xd;
    similar_code([Q1,N1|COLA],[Q2,N2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    return_statement(X, _, expression(E1), _, _, _),&#xd;
    return_statement(Y, _, expression(E2), _, _, _),&#xd;
    !,&#xd;
    similar_code([E1|COLA],[E2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    super_constructor_invocation(X, _, _, _, _, _, type_declaration(T1), _),&#xd;
    super_constructor_invocation(Y, _, _, _, _, _, type_declaration(T2), _),&#xd;
    !,&#xd;
    similar_type(T1,T2),&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    super_field_access(X, _, field(F1), _, _, _),&#xd;
    super_field_access(Y, _, field(F2), _, _, _),&#xd;
    !,&#xd;
    similar_code([F1|COLA],[F2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    super_method_invocation(X, _, method(M1), _, _, _, _),&#xd;
    super_method_invocation(Y, _, method(M2), _, _, _, _),&#xd;
    !,&#xd;
    similar_method(M1,M2),&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    super_method_reference(X, _, method(M1), _, _, _, _),&#xd;
    super_method_reference(Y, _, method(M2), _, _, _, _),&#xd;
    !,&#xd;
    similar_method(M1,M2),&#xd;
    similar_code(COLA,COLA2).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    switch_case(X, _, case(C1), _, _, _),&#xd;
    switch_case(Y, _, case(C2), _, _, _),&#xd;
    !,&#xd;
    similar_code([C1|COLA],[C2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    switch_statement(X, _, switch(S1), statements(ST1), _, _, _),&#xd;
    switch_statement(Y, _, switch(S2), statements(ST2), _, _, _),&#xd;
    !,&#xd;
    append(ST1,COLA,NEWCOLA),&#xd;
    append(ST2,COLA2,NEWCOLA2),&#xd;
    similar_code([S1|NEWCOLA],[S2|NEWCOLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    synchronized_statement(X, _, synchronized(S1), body(B1), _, _, _),&#xd;
    synchronized_statement(Y, _, synchronized(S2), body(B2), _, _, _),&#xd;
    !,&#xd;
    similar_code([S1,B1|COLA],[S2,B2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    try_statement(X, _, _, body(B1), catchs(C1), finally(F1), _, _, _),&#xd;
    try_statement(Y, _, _, body(B2), catchs(C2), finally(F2), _, _, _),&#xd;
    !,&#xd;
    append(C1,COLA,NEWCOLA),&#xd;
    append(C2,COLA2,NEWCOLA2),&#xd;
    similar_code([B1,F1|NEWCOLA],[B2,F2|NEWCOLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    variable_declaration(X, _, _, type(T1), _, extra_dimensions(D), initializer(I1), body_declaration(B1), _, _),            &#xd;
    variable_declaration(Y, _, _, type(T2), _, extra_dimensions(D), initializer(I2), body_declaration(B2), _, _),&#xd;
    !,&#xd;
    B1 \= B2,&#xd;
    similar_type(T1,T2),&#xd;
    similar_code([I1|COLA],[I2|COLA2]).&#xd;
&#xd;
similar_code([X|COLA],[Y|COLA2]):-&#xd;
    X \= Y,&#xd;
    while_statement(X, _, condition(C1), body(B1), _, _, _),&#xd;
    while_statement(Y, _, condition(C2), body(B2), _, _, _),&#xd;
    !,&#xd;
    similar_code([C1,B1|COLA],[C2,B2|COLA2]).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Characters (atom_codes)</title>
      <description>Predicates for analyzing classes names, fields names and methods names</description>
      <predicates>/* The Prolog pre-built predicate atom_codes(TEXT,CODES), translates a String to the list of char codes */&#xd;
/* Example -&gt; atom_codes(&apos;get&apos;,X) --&gt; X = [103, 101, 116] */&#xd;
&#xd;
/* Determine if the char code is a letter or a number*/&#xd;
&#xd;
letter(X):-&#xd;
    (&#xd;
        X &gt; 96,&#xd;
        X &lt; 123&#xd;
    );&#xd;
    (&#xd;
        X &gt; 64,&#xd;
        X &lt; 91&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
is_number(X):-&#xd;
	X &gt; 47,&#xd;
	X &lt; 59.&#xd;
&#xd;
/* Determine if two atom codes are the same letter */&#xd;
/* This is not case sensitive, for example, &apos;p&apos; and &apos;P&apos; are the same letter */&#xd;
&#xd;
same_letter(97,65).&#xd;
same_letter(65,97).&#xd;
same_letter(98,66).&#xd;
same_letter(66,98).&#xd;
same_letter(99,67).&#xd;
same_letter(67,99).&#xd;
same_letter(100,68).&#xd;
same_letter(68,100).&#xd;
same_letter(101,69).&#xd;
same_letter(69,101).&#xd;
same_letter(102,70).&#xd;
same_letter(70,102).&#xd;
same_letter(103,71).&#xd;
same_letter(71,103).&#xd;
same_letter(104,72).&#xd;
same_letter(72,104).&#xd;
same_letter(105,73).&#xd;
same_letter(73,105).&#xd;
same_letter(106,74).&#xd;
same_letter(74,106).&#xd;
same_letter(107,75).&#xd;
same_letter(75,107).&#xd;
same_letter(108,76).&#xd;
same_letter(76,108).&#xd;
same_letter(109,77).&#xd;
same_letter(77,109).&#xd;
same_letter(110,78).&#xd;
same_letter(78,110).&#xd;
same_letter(111,79).&#xd;
same_letter(79,111).&#xd;
same_letter(112,80).&#xd;
same_letter(80,112).&#xd;
same_letter(113,81).&#xd;
same_letter(81,113).&#xd;
same_letter(114,82).&#xd;
same_letter(82,114).&#xd;
same_letter(115,83).&#xd;
same_letter(83,115).&#xd;
same_letter(116,84).&#xd;
same_letter(84,116).&#xd;
same_letter(117,85).&#xd;
same_letter(85,117).&#xd;
same_letter(118,86).&#xd;
same_letter(86,118).&#xd;
same_letter(119,87).&#xd;
same_letter(87,119).&#xd;
same_letter(120,88).&#xd;
same_letter(88,120).&#xd;
same_letter(121,89).&#xd;
same_letter(89,121).&#xd;
same_letter(122,90).&#xd;
same_letter(90,122).&#xd;
same_letter(97,97).&#xd;
same_letter(65,65).&#xd;
same_letter(98,98).&#xd;
same_letter(66,66).&#xd;
same_letter(99,99).&#xd;
same_letter(67,67).&#xd;
same_letter(100,100).&#xd;
same_letter(68,68).&#xd;
same_letter(101,101).&#xd;
same_letter(69,69).&#xd;
same_letter(102,102).&#xd;
same_letter(70,70).&#xd;
same_letter(103,103).&#xd;
same_letter(71,71).&#xd;
same_letter(104,104).&#xd;
same_letter(72,72).&#xd;
same_letter(105,105).&#xd;
same_letter(73,73).&#xd;
same_letter(106,106).&#xd;
same_letter(74,74).&#xd;
same_letter(107,107).&#xd;
same_letter(75,75).&#xd;
same_letter(108,108).&#xd;
same_letter(76,76).&#xd;
same_letter(109,109).&#xd;
same_letter(77,77).&#xd;
same_letter(110,110).&#xd;
same_letter(78,78).&#xd;
same_letter(111,111).&#xd;
same_letter(79,79).&#xd;
same_letter(112,112).&#xd;
same_letter(80,80).&#xd;
same_letter(113,113).&#xd;
same_letter(81,81).&#xd;
same_letter(114,114).&#xd;
same_letter(82,82).&#xd;
same_letter(115,115).&#xd;
same_letter(83,83).&#xd;
same_letter(116,116).&#xd;
same_letter(84,84).&#xd;
same_letter(117,117).&#xd;
same_letter(85,85).&#xd;
same_letter(118,118).&#xd;
same_letter(86,86).&#xd;
same_letter(119,119).&#xd;
same_letter(87,87).&#xd;
same_letter(120,120).&#xd;
same_letter(88,88).&#xd;
same_letter(121,121).&#xd;
same_letter(89,89).&#xd;
same_letter(122,122).&#xd;
same_letter(90,90).&#xd;
&#xd;
/* Check if two texts are similar (this is not case sensitive) */&#xd;
&#xd;
similar_texts(TEXT1,TEXT2):-&#xd;
	atom_codes(TEXT1,CODES1),&#xd;
	atom_codes(TEXT2,CODES2),&#xd;
	similar_chars(CODES1,CODES2).&#xd;
&#xd;
/* Check if two list of atom codes are similar */&#xd;
&#xd;
similar_chars([],[]).&#xd;
&#xd;
similar_chars([X|RESTO1],[Y|RESTO2]):-&#xd;
	same_letter(X,Y),&#xd;
	!,&#xd;
	contains_chars(RESTO1,RESTO2).&#xd;
&#xd;
/* Check if a list of atom codes contains a number */&#xd;
&#xd;
contains_number([X|REST]):-&#xd;
	is_number(X),&#xd;
	!.&#xd;
&#xd;
contains_number([X|REST]):-&#xd;
	contains_number(REST),&#xd;
	!.&#xd;
&#xd;
/* Check if WORD1 contains WORD2 */&#xd;
&#xd;
contains_word(WORD1,WORD2):-&#xd;
	atom_codes(WORD1,CODES1),&#xd;
	atom_codes(WORD2,CODES2),&#xd;
	contains_chars(CODES1,CODES2).&#xd;
&#xd;
contains_chars(CHARS1,CHARS2):-&#xd;
	append(_,SUB,CHARS1),&#xd;
	length(SUB,N),&#xd;
	length(CHARS2,N),&#xd;
	similar_chars(SUB,CHARS2).&#xd;
&#xd;
/* Checks if WORD1 starts with WORD2 */&#xd;
&#xd;
starts_with(WORD1,WORD2):-&#xd;
	atom_codes(WORD1,CODES1),&#xd;
	atom_codes(WORD2,CODES2),&#xd;
	start_with_chars(CODES1,CODES2).&#xd;
&#xd;
start_with_chars(CHARS1,CHARS2):-&#xd;
	append(SUB,_,CHARS1),&#xd;
	length(SUB,N),&#xd;
	length(CHARS2,N),&#xd;
	similar_chars(SUB,CHARS2).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Classes (modifiers and main)</title>
      <description>Check if a field class some characteristics (like if the class is public, or it is the main class, etc.)</description>
      <predicates>/* Check if a class is an abstract class or returns an abstract class if ID is not specified */&#xd;
&#xd;
abstract_class(ID):-&#xd;
    class_declaration(ID, _, _, _, modifiers(MODIFIERS), _, _, _, _, _, _),&#xd;
	member(&apos;abstract&apos;, MODIFIERS).&#xd;
&#xd;
/* Check if a class is the main class or returns the main class if ID is not specified */&#xd;
&#xd;
main_class(ID):-&#xd;
    method_declaration(METHOD, parent(ID), &apos;main&apos;, _, parameters([ARGS]), parameters_types([STRING_ARRAY]), return_type(RETURN), dimensions(0), _, _, _),&#xd;
    class_declaration(ID, _, _, _, _, _, _, _, _, _, _),&#xd;
    public_method(METHOD),&#xd;
    static_method(METHOD),&#xd;
    primitive_type(RETURN, code(&apos;void&apos;)),&#xd;
    (&#xd;
        (&#xd;
            array_type(STRING_ARRAY, array_of(STRING), dimensions(1)),&#xd;
            type(STRING, name(&apos;String&apos;))&#xd;
        );&#xd;
        (&#xd;
            type(STRING_ARRAY, name(&apos;String&apos;)),&#xd;
            variable_declaration(ARGS, _, _, _, _, extra_dimensions(1), _, _, _, _)&#xd;
        )&#xd;
    ).&#xd;
</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Compilation units (.java)</title>
      <description>Check if a compilation unit fills some characteristics (like if the unit defines the main class)</description>
      <predicates>/* Check if the .java is a model unit (i.e if the .java does not contain the main class */&#xd;
&#xd;
model_unit(ID):-&#xd;
	model_unit_chechked(ID),&#xd;
	!.&#xd;
&#xd;
model_unit(ID):-&#xd;
    method_declaration(METHOD, _, &apos;main&apos;, _, parameters([ARGS]), parameters_types([STRING_ARRAY]), return_type(RETURN), dimensions(0), _, _, compilation_unit(ID)),&#xd;
    public_method(METHOD),&#xd;
    static_method(METHOD),&#xd;
    primitive_type(RETURN, code(&apos;void&apos;)),&#xd;
    (&#xd;
        (&#xd;
            array_type(STRING_ARRAY, array_of(STRING), dimensions(1)),&#xd;
            type(STRING, name(&apos;String&apos;))&#xd;
        );&#xd;
        (&#xd;
            type(STRING_ARRAY, name(&apos;String&apos;)),&#xd;
            variable_declaration(ARGS, _, _, _, _, extra_dimensions(1), _, _, _, _)&#xd;
        )&#xd;
    ),&#xd;
    !,&#xd;
    fail.&#xd;
&#xd;
model_unit(ID):-&#xd;
    assert(model_unit_chechked(ID)).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Methods (filters)</title>
      <description>Filter a list of methods according to some characteristics</description>
      <predicates>/* Discards every constructor, retaining only methods */&#xd;
&#xd;
filter_methods([],[]):- !.&#xd;
&#xd;
filter_methods([CONSTRUCTOR|COLA],COLA2):-&#xd;
    constructor_declaration(CONSTRUCTOR, _, _, _, _, _, _, _, _, _, _),&#xd;
    filter_methods(COLA,COLA2),&#xd;
    !.  &#xd;
    &#xd;
filter_methods([METHOD|COLA],[METHOD|COLA2]):-&#xd;
    filter_methods(COLA,COLA2).&#xd;
&#xd;
/* Discards every method, retaining only constructos */&#xd;
&#xd;
filter_constructors([],[]):- !.&#xd;
&#xd;
filter_constructors([METHOD|COLA],COLA2):-&#xd;
    method_declaration(METHOD, _, _, _, _, _, _, _, _, _, _),&#xd;
    filter_constructors(COLA,COLA2),&#xd;
    !.  &#xd;
    &#xd;
filter_constructors([METHOD|COLA],[METHOD|COLA2]):-&#xd;
    filter_constructors(COLA,COLA2).&#xd;
&#xd;
/* Discard every access method (getter and setters), retaining only behaviors */&#xd;
&#xd;
filter_behaviours([],[]):- !.&#xd;
&#xd;
filter_behaviours([METHOD|COLA],COLA2):-&#xd;
    define_access(METHOD),&#xd;
    filter_behaviours(COLA,COLA2),&#xd;
    !.  &#xd;
    &#xd;
filter_behaviours([METHOD|COLA],[METHOD|COLA2]):-&#xd;
    filter_behaviours(COLA,COLA2).&#xd;
&#xd;
/* Discards every public method, retaining non public methods */&#xd;
&#xd;
filter_public_methods([],[]).&#xd;
&#xd;
filter_public_methods([METHOD|COLA],[METHOD|COLA2]):-&#xd;
    public_method(METHOD),&#xd;
    filter_public_methods(COLA,COLA2),&#xd;
    !.&#xd;
&#xd;
filter_public_methods([METHOD|COLA],COLA2):-&#xd;
    filter_public_methods(COLA,COLA2).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Methods (getters/setters)</title>
      <description>Checks if a method is a getter/setter or a behavior</description>
      <predicates>/* Check if the method name starts with set, add, put, get, or is */&#xd;
&#xd;
starts_with_set(WORD):-&#xd;
	starts_with(WORD,&apos;set&apos;).&#xd;
&#xd;
starts_with_add(WORD):-&#xd;
	starts_with(WORD,&apos;add&apos;).&#xd;
&#xd;
starts_with_put(WORD):-&#xd;
	starts_with(WORD,&apos;put&apos;).&#xd;
&#xd;
starts_with_get(WORD):-&#xd;
	starts_with(WORD,&apos;get&apos;);&#xd;
	starts_with(WORD,&apos;is&apos;).&#xd;
&#xd;
/* Check if the method name represents the getter of a specific field (name comparision) */&#xd;
&#xd;
get_name(METHOD_NAME,FIELD_NAME):-&#xd;
	atom_concat(GET,NAME,METHOD_NAME),&#xd;
	(&#xd;
		similar_texts(GET,&apos;get&apos;);&#xd;
		similar_texts(GET,&apos;is&apos;)&#xd;
	),&#xd;
	atom_codes(NAME,CODES1),&#xd;
	atom_codes(FIELD_NAME,CODES2),&#xd;
	get_name2(CODES1,CODES2),&#xd;
	!.&#xd;
		&#xd;
get_name2([],[]):- !.&#xd;
&#xd;
get_name2([],_):- !.&#xd;
&#xd;
get_name2(_,[]):- !.&#xd;
&#xd;
get_name2([X|REST1],[Y|REST2]):-&#xd;
    same_letter(X,Y),&#xd;
    !,&#xd;
    get_name2(REST1,REST2).&#xd;
&#xd;
get_name2([X|REST1],REST2):-&#xd;
    not(letter(X)),&#xd;
    !,&#xd;
    get_name2(REST1,REST2).&#xd;
&#xd;
get_name2(REST1,[X|REST2]):-&#xd;
    not(letter(X)),&#xd;
    !,&#xd;
    get_name2(REST1,REST2).&#xd;
&#xd;
/* Check if the method is a setter */&#xd;
/* The first predicate checks it by the method definition: the method must return void, must starts with &apos;set&apos; &apos;add&apos; or &apos;put&apos;, etc. */&#xd;
/* The second checks it by the method behavior: the method must assign a parameter to a field */&#xd;
&#xd;
is_setter(ID):-&#xd;
    method_declaration(ID, _, METHOD_NAME, _, parameters(PARAMETERS), _, return_type(VOID), _, body(BODY), _, _),&#xd;
    BODY \= null,&#xd;
    public_method(ID),&#xd;
    primitive_type(VOID, code(&apos;void&apos;)),&#xd;
    (&#xd;
        length(PARAMETERS,1);&#xd;
        length(PARAMETERS,2)&#xd;
    ),&#xd;
    (&#xd;
        starts_with_set(METHOD_NAME);&#xd;
        starts_with_add(METHOD_NAME);&#xd;
        starts_with_put(METHOD_NAME)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
is_setter(ID):-&#xd;
    method_declaration(ID, _, METHOD_NAME, _, parameters(PARAMETERS), parameters_types(PARAMETERS_TYPES), return_type(VOID), _, body(BODY), _, _),&#xd;
    BODY \= null,&#xd;
    public_method(ID),&#xd;
    primitive_type(VOID, code(&apos;void&apos;)),&#xd;
    length(PARAMETERS,1),&#xd;
    block(BODY, _, statements([ASSIGNMENT]), _, _, _),&#xd;
    assignment(ASSIGNMENT, _, operator(&apos;ASSIGN&apos;), left_operand(EXP), _, _, _, _),&#xd;
    field_access(EXP,FIELD),&#xd;
    field_declaration(FIELD, _, _, type(FIELD_TYPE), _, _, _, _),&#xd;
    member(PARAM_TYPE,PARAMETERS_TYPES),&#xd;
    similar_type(FIELD_TYPE,PARAM_TYPE),&#xd;
    !.&#xd;
&#xd;
/* Check if the method is a getter (by name or by behavior) */&#xd;
&#xd;
is_getter(ID):-&#xd;
    method_declaration(ID, parent(CLASS), METHOD_NAME, _, parameters([]), _, return_type(RETURN_TYPE), _, body(BODY), _, _),&#xd;
    BODY \= null,&#xd;
    public_method(ID),&#xd;
    not(primitive_type(RETURN_TYPE, code(&apos;void&apos;))),&#xd;
    (&#xd;
        field_declaration(FIELD, parent(CLASS), FIELD_NAME, type(FIELD_TYPE), _, _, _, _);&#xd;
        (&#xd;
            is_super(CLASS_2,CLASS),&#xd;
            field_declaration(FIELD, parent(CLASS_2), FIELD_NAME, type(FIELD_TYPE), _, _, _, _)&#xd;
        )&#xd;
    ),&#xd;
    similar_type(RETURN_TYPE,FIELD_TYPE),&#xd;
    (&#xd;
        get_name(METHOD_NAME,FIELD_NAME);&#xd;
        (&#xd;
            block(BODY, _, statements([RETURN]), _, _, _),&#xd;
            return_statement(RETURN, _, expression(EXP), _, _, _),&#xd;
            field_access(EXP,FIELD)&#xd;
        )&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
/* Check if the method gets an element of a Java List (i.e &apos;get(index)&apos; )*/&#xd;
&#xd;
is_list_item_getter(ID):-&#xd;
    method_declaration(ID, parent(CLASS), METHOD_NAME, _, _, parameters_types([INDEX_TYPE]), return_type(RETURN_TYPE), _, body(BODY), _, _),&#xd;
    public_method(ID),&#xd;
    BODY \= null,&#xd;
    starts_with_get(METHOD_NAME),&#xd;
    (&#xd;
        primitive_type(INDEX_TYPE,code(&apos;int&apos;));&#xd;
        type(INDEX_TYPE , name(&apos;Integer&apos;))&#xd;
    ),&#xd;
    field_declaration(FIELD, parent(CLASS), _, type(LIST),  _, _, _, _),&#xd;
    (&#xd;
        (&#xd;
            list_type(LIST),&#xd;
            parameterized_type(LIST, _, parameters([RETURN_TYPE]))&#xd;
        );&#xd;
        array_type(LIST, array_of(RETURN_TYPE), _)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
/* Check if the method gets an element of a Java Map (i.e &apos;get(key)&apos; )*/&#xd;
&#xd;
is_hm_item_getter(ID):-&#xd;
    method_declaration(ID, parent(CLASS), METHOD_NAME, _, parameters([PARAM]), parameters_types([INDEX_TYPE]), return_type(RETURN_TYPE), _, body(BODY), _, _),&#xd;
    public_method(ID),&#xd;
    BODY \= null,&#xd;
    starts_with_get(METHOD_NAME),&#xd;
    field_declaration(FIELD, parent(CLASS), _, type(MAP),  _, _, _, _),&#xd;
    map_type(MAP),&#xd;
    parameterized_type(MAP, _, parameters([INDEX_TYPE,RETURN_TYPE])),&#xd;
    method_invocation(INVOCATION, _, expression(EXP), method(GET), arguments([PARAM]), body_declaration(ID), _, _),&#xd;
    field_access(EXP,FIELD),&#xd;
    method(GET, name(&apos;get&apos;), _, _),&#xd;
    !.&#xd;
&#xd;
/* Check if the method is a getter/setter */&#xd;
&#xd;
define_access(ID):-&#xd;
    (&#xd;
        is_setter(ID); &#xd;
        is_getter(ID);&#xd;
        is_list_item_getter(ID);&#xd;
        is_hm_item_getter(ID)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
/* Check if a method defines behavior (i.e it is not a getter/setter) */&#xd;
&#xd;
define_behaviour(ID):-&#xd;
    method_declaration(ID, _, _, _, _, _, _, _, _, _, _),&#xd;
    not(define_access(ID)).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Classes hierarchy</title>
      <description>Check if two classes have common ancestors, share methods or share fields</description>
      <predicates>/* Check that ID represents a type */&#xd;
&#xd;
is_type(ID):-&#xd;
	class_declaration(ID, _, _, _, _, _, _, _, _, _, _);&#xd;
	interface_declaration(ID, _, _, _, _, _, _, _, _, _);&#xd;
	enum_declaration(ID, _, _, _, _, _, _, _);&#xd;
	type(ID,_).&#xd;
&#xd;
/* List every ancestor class for a specified class */&#xd;
&#xd;
list_super_classes(ID,[]):-&#xd;
    (&#xd;
        parameterized_type(ID, _, _);&#xd;
        primitive_type(ID, _);&#xd;
        wildcard_type(ID, _, _);&#xd;
        array_type(ID, _, _);&#xd;
        type(ID, _);&#xd;
        interface_declaration(ID, _, _, _, _, _, _, _, _, _);&#xd;
        class_declaration(ID, _, _, _, _, super_type(null), _, _, _, _, _)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
list_super_classes(ID,[SID|COLA]):-&#xd;
    class_declaration(ID, _, _, _, _, super_type(SID), _, _, _, _, _),&#xd;
    list_super_classes(SID,COLA).&#xd;
&#xd;
/* List every ancestor interface for a specified class or interface */&#xd;
&#xd;
list_super_interfaces(ID,[]):-&#xd;
    (&#xd;
        parameterized_type(ID, _, _);&#xd;
        primitive_type(ID, _);&#xd;
        wildcard_type(ID, _, _);&#xd;
        array_type(ID, _, _);&#xd;
        type(ID, _);&#xd;
        interface_declaration(ID, _, _, _, _, super_type(null), _, _, _, _)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
list_super_interfaces(ID,L):-&#xd;
    interface_declaration(ID, _, _, _, _, super_type(I), _, _, _, _),&#xd;
    list_super_interfaces(I,L),&#xd;
    !.&#xd;
&#xd;
list_super_interfaces(ID,L):-&#xd;
    class_declaration(ID, _, _, _, _, super_type(null), implements(I), _, _, _, _),&#xd;
    list_super_interfaces(I,L2),&#xd;
    append_set(L1,L2,L),&#xd;
    !.&#xd;
&#xd;
list_super_interfaces(ID,L):-&#xd;
    class_declaration(ID, _, _, _, _, super_type(SID), implements(I), _, _, _, _),&#xd;
    list_super_interfaces(SID,L1),&#xd;
    list_super_interfaces(I,L2),&#xd;
    append_set(L1,L2,L),&#xd;
    !.&#xd;
&#xd;
list_super_interfaces([],[]).&#xd;
&#xd;
list_super_interfaces([ID|COLA],[ID|L]):-&#xd;
    list_super_interfaces(ID,L1),&#xd;
    list_super_interfaces(COLA,L2),&#xd;
    append_set(L1,L2,L).&#xd;
&#xd;
/* List every ancestor class or interface for a specified class or interface */&#xd;
&#xd;
list_super_types(ID,LIST):-&#xd;
    list_super_types_checked(ID,LIST),&#xd;
    !.&#xd;
&#xd;
list_super_types(ID,L):-&#xd;
    list_super_classes(ID,CL),&#xd;
    list_super_interfaces(ID,IL),&#xd;
    append(CL,IL,L),&#xd;
    assert(list_super_types_checked(ID,L)).&#xd;
&#xd;
/* Check if SID is an ancestor of ID, or returns an ancestor of ID if SID is not specified */&#xd;
&#xd;
is_super(SID,ID):-&#xd;
    list_super_types(ID,L),&#xd;
    member(SID,L).&#xd;
&#xd;
/* Check if the third parameter is a common ancestor between X and Y */&#xd;
/* If the third parameter is not specified, the predicate returns a common anncestor betweet X and Y, if any */&#xd;
&#xd;
common_super(X,Y,X):-&#xd;
    is_super(X,Y),&#xd;
    !.&#xd;
&#xd;
common_super(X,Y,Y):-&#xd;
    is_super(Y,X),&#xd;
    !.&#xd;
&#xd;
common_super(X,Y,Z):-&#xd;
    is_super(Z,X),&#xd;
    is_super(Z,Y),&#xd;
    !.&#xd;
&#xd;
/* This predicate builds a list with all the classes / intarfaces in the hierarchy tree of TYPE */&#xd;
/* The hierarchy is built and asserted since it is expensive to build it everytime */&#xd;
&#xd;
hierarchy(TYPE,LIST):-&#xd;
    hierarchy_checked(TYPE,LIST), !.&#xd;
&#xd;
hierarchy(TYPE,LIST):-&#xd;
    findall(AUX,same_hierarchy(TYPE,AUX),LIST),&#xd;
    assert(hierarchy_checked(TYPE,LIST)).&#xd;
&#xd;
same_hierarchy(TYPE_1,TYPE_2):-&#xd;
    is_type(TYPE_1),&#xd;
    is_type(TYPE_2),&#xd;
    common_super(TYPE_1,TYPE_2,SUPER).&#xd;
&#xd;
same_hierarchy(TYPE,TYPE):-&#xd;
    not(is_super(_,TYPE)).&#xd;
&#xd;
/* Check if a class has a specified method */&#xd;
/* The class C has the method M if C defines M, or if C parent has M */&#xd;
/* Note that if any point M is redefined with a different behavior (lets say M2), then C has not the method M (instead C has the redefined method M2) */&#xd;
&#xd;
has_method(CLASS,METHOD):-&#xd;
    method_declaration(METHOD, parent(CLASS), _, _, _, _, _, _, _, _, _),&#xd;
    !.&#xd;
&#xd;
has_method(CLASS,METHOD):-&#xd;
    method_declaration(METHOD, parent(PARENT), NAME, _, _, parameters_types(PARAMETER_TYPES), _, dimensions(D), _, _, _),&#xd;
    PARENT \= CLASS,&#xd;
    not(method_declaration(METHOD_2, parent(CLASS), NAME, _, _, parameters_types(PARAMETER_TYPES), _, dimensions(D), _, _, _)),&#xd;
    (&#xd;
        class_declaration(CLASS, _, _, _, _, super_type(SUPER), implements(IMPLEMENTS), _, _, _, _);&#xd;
        interface_declaration(CLASS, _, _, _, _, super_type(SUPER), _, _, _, _)&#xd;
    ),&#xd;
    (&#xd;
        (&#xd;
            SUPER \= null,&#xd;
            has_method(SUPER,METHOD)&#xd;
        );&#xd;
        (&#xd;
            member(INTERFACE,IMPLEMENTS),&#xd;
            has_method(INTERFACE,METHOD)&#xd;
        )&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
/* Check if a class has a specified field */&#xd;
/* The class C has the field F if C defines F, or if C parent has F and F is not private */&#xd;
&#xd;
has_field(CLASS,FIELD):-&#xd;
	field_declaration(FIELD, parent(CLASS), _, _, _, _, _, _),&#xd;
	!.&#xd;
&#xd;
has_field(CLASS,FIELD):-&#xd;
	field_declaration(FIELD, parent(SUPER), _, _, _, _, _, _),&#xd;
	CLASS \= SUPER,&#xd;
    is_super(SUPER,CLASS),&#xd;
    not(private_field(FIELD)),&#xd;
    !.</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Object methods</title>
      <description>Check if a method is a predefined object method</description>
      <predicates>/* Check if a method is an object method */&#xd;
&#xd;
object_method(METHOD):-&#xd;
    (&#xd;
        is_equals(METHOD);&#xd;
        is_tostring(METHOD);&#xd;
        is_hashcode(METHOD);&#xd;
        is_wait(METHOD);&#xd;
        is_getClass(METHOD);&#xd;
        is_notify(METHOD);&#xd;
        is_notifyAll(METHOD)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
/* Check if a method is the &apos;equals&apos; method */&#xd;
&#xd;
is_equals(ID):-&#xd;
    method(ID, name(&apos;equals&apos;), _, _).&#xd;
&#xd;
is_equals(ID):-&#xd;
    method_declaration(ID, _, &apos;equals&apos;, _, _, parameters_types([OBJECT]), return_type(BOOLEAN), dimensions(0), _, _, _),&#xd;
    primitive_type(BOOLEAN, code(&apos;boolean&apos;)),&#xd;
    type(OBJECT , name(&apos;Object&apos;)).&#xd;
&#xd;
/* Check if a method is the &apos;toString&apos; method */&#xd;
&#xd;
is_tostring(ID):-&#xd;
    method(ID, name(&apos;toString&apos;), _, _).&#xd;
&#xd;
is_tostring(ID):-&#xd;
    method_declaration(ID, _, &apos;toString&apos;, _, _, parameters_types([]), return_type(STRING), dimensions(0), _, _, _),&#xd;
    type(STRING, name(&apos;String&apos;)).&#xd;
&#xd;
/* Check if a method is the &apos;hashCode&apos; method */&#xd;
&#xd;
is_hashcode(ID):-&#xd;
    method(ID, name(&apos;hashCode&apos;), _, _).&#xd;
&#xd;
is_hashcode(ID):-&#xd;
    method_declaration(ID, _, &apos;hashCode&apos;, _, _, parameters_types([]), return_type(INT), dimensions(0), _, _, _),&#xd;
    primitive_type(INT, code(&apos;int&apos;)).&#xd;
&#xd;
/* Check if a method is the &apos;getClass&apos; method */&#xd;
&#xd;
is_getclass(ID):-&#xd;
    method(ID, name(&apos;getClass&apos;), _, _).&#xd;
  &#xd;
/* Check if a method is the &apos;notify&apos; method */&#xd;
&#xd;
is_notify(ID):-&#xd;
    method(ID, name(&apos;notify&apos;), _, _).&#xd;
    &#xd;
/* Check if a method is the &apos;notifyAll&apos; method */&#xd;
&#xd;
is_notifyAll(ID):-&#xd;
    method(ID, name(&apos;notifyAll&apos;), _, _).&#xd;
&#xd;
/* Check if a method is the &apos;wait&apos; method */&#xd;
&#xd;
is_wait(ID):-&#xd;
    method(ID, name(&apos;wait&apos;), _, _).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Resolve expressions (references)</title>
      <description>Resolve to what element is referencing an expression (a variable, a field, a method, etc.)</description>
      <predicates>/* Check if a expression is a field access */&#xd;
&#xd;
field_access(FIELD,FIELD):-&#xd;
    field_declaration(FIELD, _, _, _, _, _, _, _).&#xd;
&#xd;
field_access(ACCESS,FIELD):-&#xd;
    field_access(ACCESS, _, expression(THIS), field(FIELD), _, _, _),&#xd;
    field_declaration(FIELD, _, _, _, _, _, _, _),&#xd;
    this_expression(THIS, _, expression(null), _, _, _).&#xd;
&#xd;
field_access(ACCESS,FIELD):-&#xd;
    cast_expression(ACCESS, _, _, expression(EXP), _, _, _),&#xd;
    field_access(EXP,FIELD).&#xd;
&#xd;
/* Check if a expression is a variable access */&#xd;
&#xd;
var_access(VAR,VAR):-&#xd;
    variable_declaration(VAR, _, _, _, _, _, _, _, _, _).&#xd;
&#xd;
var_access(ACCESS,VAR):-&#xd;
    cast_expression(ACCESS, _, _, expression(EXP), _, _, _),&#xd;
    var_access(EXP,VAR).&#xd;
&#xd;
/* Resolves an expression and determines the accessed element: a variable, a field, a method inocation or a literal */&#xd;
&#xd;
resolve_expression(EXP,RESOLVED):-&#xd;
    field_access(EXP,RESOLVED),&#xd;
    !.&#xd;
&#xd;
resolve_expression(EXP,RESOLVED):-&#xd;
    var_access(EXP,RESOLVED),&#xd;
    !.&#xd;
&#xd;
resolve_expression(RESOLVED,RESOLVED):-&#xd;
    method_invocation(RESOLVED, _, _, _, _, _, _, _),&#xd;
    !.&#xd;
&#xd;
resolve_expression(RESOLVED,RESOLVED):-&#xd;
    (&#xd;
        boolean_literal(RESOLVED,_,_,_,_,_);&#xd;
        character_literal(RESOLVED,_,_,_,_,_);&#xd;
        number_literal(RESOLVED,_,_,_,_,_);&#xd;
        null_literal(RESOLVED,_,_,_,_);&#xd;
        string_literal(RESOLVED,_,_,_,_,_)&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
resolve_expression(NAME,RESOLVED):-&#xd;
    qualified_name(NAME, _, _, name(EXP), _, _, _),&#xd;
    resolve_expression(EXP,RESOLVED),&#xd;
    !.&#xd;
&#xd;
resolve_expression(CAST,RESOLVED):-&#xd;
    cast_expression(CAST, _, _, expression(EXP), _, _, _),&#xd;
    resolve_expression(EXP,RESOLVED),&#xd;
    !.&#xd;
</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Need for using equals</title>
      <description>Check if the type of a field, a variable or a method invocation, needs for using equals.</description>
      <predicates>/* Check if ID needs using equals (to compare objects) or can use == (to compare something primitive) */&#xd;
/* ID can represent a variable, a field or a method invocation */&#xd;
&#xd;
need_equals(ID):-&#xd;
    string_literal(ID,_,_,_,_,_);&#xd;
    (&#xd;
        (&#xd;
            field_declaration(ID, _, _, type(TYPE), _, _, _, _);&#xd;
            variable_declaration(ID, _, _, type(TYPE), _, _, _, _, _, _);&#xd;
            (&#xd;
            	method_invocation(ID, _, _,  method(METHOD), _, _, _, _),&#xd;
            	method_declaration(METHOD, _, _, _, _, _, return_type(TYPE), _, _, _, _)&#xd;
            )&#xd;
        ),&#xd;
        not(primitive_type(TYPE,_))&#xd;
    ),&#xd;
    !.</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Methods (auxiliary)</title>
      <description>Auxiliary predicates that focus on methods</description>
      <predicates>/* Check if the method invocation is printing by console (i.e &apos;System.out.println(&quot;content&quot;)&apos; )*/&#xd;
&#xd;
is_print(ID):-&#xd;
    nonvar(ID),&#xd;
    method_invocation(ID, _, expression(SYSOUT), method(PRINT), _, _, _, _),&#xd;
    qualified_name(SYSOUT, _, qualified(SYSTEM), name(OUT), _, _, _),&#xd;
    type(SYSTEM, name(&apos;System&apos;)),&#xd;
    variable(OUT, name(&apos;out&apos;), _),&#xd;
    (&#xd;
        method(PRINT, name(&apos;println&apos;), _, _);&#xd;
        method(PRINT, name(&apos;print&apos;), _, _)&#xd;
    ).&#xd;
&#xd;
is_print(ID):-&#xd;
    var(ID),&#xd;
    type(SYSTEM, name(&apos;System&apos;)),&#xd;
    variable(OUT, name(&apos;out&apos;), _),&#xd;
    qualified_name(SYSOUT, _, qualified(SYSTEM), name(OUT), _, _, _),&#xd;
    method_invocation(ID, _, expression(SYSOUT), method(PRINT), _, _, _, _),&#xd;
    (&#xd;
        method(PRINT, name(&apos;println&apos;), _, _);&#xd;
        method(PRINT, name(&apos;print&apos;), _, _)&#xd;
    ).&#xd;
&#xd;
/* Check if METHOD is redefining SUPER_METHOD */&#xd;
&#xd;
redefine_method(METHOD,SUPER_METHOD):-&#xd;
    method_declaration(METHOD, parent(CLASS), NAME, _, _, parameters_types(PARAMETER_TYPES), _, _, _, _, _),&#xd;
    method_declaration(SUPER_METHOD, parent(SUPER_CLASS), NAME, _, _, parameters_types(PARAMETER_TYPES), _, _, _, _, _),&#xd;
    METHOD \= SUPER_METHOD,&#xd;
    is_super(SUPER_CLASS,CLASS),&#xd;
    !.&#xd;
&#xd;
redefine_method(METHOD,SUPER_METHOD):-&#xd;
    nonvar(METHOD),&#xd;
    nonvar(SUPER_METHOD),&#xd;
    (&#xd;
        (&#xd;
            is_equals(METHOD),&#xd;
            is_equals(SUPER_METHOD)&#xd;
        );&#xd;
        (&#xd;
            is_wait(METHOD),&#xd;
            is_wait(SUPER_METHOD)&#xd;
        );&#xd;
        (&#xd;
            is_tostring(METHOD),&#xd;
            is_tostring(SUPER_METHOD)&#xd;
        );&#xd;
        (&#xd;
            is_hashcode(METHOD),&#xd;
            is_hashcode(SUPER_METHOD)&#xd;
        );&#xd;
        (&#xd;
            is_getClass(METHOD),&#xd;
            is_getClass(SUPER_METHOD)&#xd;
        )&#xd;
    ),&#xd;
    !.&#xd;
&#xd;
/* Check if two methods are similar */&#xd;
/* Two methods are similar if they have the same name, similar parameters and similar return types */&#xd;
&#xd;
similar_method(X,X):- !.&#xd;
&#xd;
similar_method(X,Y):-&#xd;
    method_declaration(X, parent(P1), NAME, _, _, parameters_types(PARAMETERS_1), return_type(R1), dimensions(D), _, _, _),&#xd;
    method_declaration(Y, parent(P2), NAME, _, _, parameters_types(PARAMETERS_2), return_type(R2), dimensions(D), _, _, _),&#xd;
    !,&#xd;
    P1 \= P2,&#xd;
    similar_type(R1,R2),&#xd;
    similar_type(P1,P2),&#xd;
    similar_type(PARAMETERS_1,PARAMETERS_2).&#xd;
&#xd;
similar_method(X,Y):-&#xd;
    method_declaration(X, _, NAME, _, _, _, _, _, _, _, _),&#xd;
    method(Y, name(NAME), _, _),&#xd;
    !.&#xd;
&#xd;
similar_method(X,Y):-&#xd;
    method_declaration(Y, _, NAME, _, _, _, _, _, _, _, _),&#xd;
    method(X, name(NAME), _, _),&#xd;
    !.&#xd;
&#xd;
similar_method(X,Y):-&#xd;
    method(X, name(NAME), _, _),&#xd;
    method(Y, name(NAME), _, _).&#xd;
&#xd;
/* Check if METHOD invokes CHILD_METHOD */&#xd;
&#xd;
delegation(METHOD,CHILD_METHOD):-&#xd;
    method_invocation(_, _, _, method(CHILD_METHOD), _, body_declaration(METHOD), _, _),&#xd;
    !.&#xd;
</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Similar types</title>
      <description>Please write a description for this predicate</description>
      <predicates>/* Check if two types (or if two list of types) are similar */&#xd;
/* For example, if A extends B: A and B are similar, A[] and B[] are similar, ArrayList&lt;A&gt; and ArrayList&lt;B&gt; are similar */&#xd;
/* Moreover, Integer is similar to int, Double is similar to double, etc. */&#xd;
&#xd;
similar_type([],[]):- !.&#xd;
&#xd;
similar_type([X|COLA],[Y|COLA2]):-&#xd;
    similar_type(X,Y),&#xd;
    similar_type(COLA,COLA2),&#xd;
    !.&#xd;
    &#xd;
similar_type(TYPE1,TYPE1):- !.&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    common_super(TYPE1,TYPE2_),&#xd;
    !.&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    parameterized_type(TYPE1, fqn(FQN), parameters(LIST1)),&#xd;
    parameterized_type(TYPE2, fqn(FQN), parameters(LIST2)),&#xd;
    similar_type(LIST1,LIST2).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    union_type(TYPE1, types(LIST1)),&#xd;
    union_type(TYPE2, types(LIST2)),&#xd;
    similar_type(LIST1,LIST2).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    intersection_type(TYPE1, types(LIST1)),&#xd;
    intersection_type(TYPE2, types(LIST2)),&#xd;
    similar_type(LIST1,LIST2).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    array_type(TYPE1, array_of(AO1), dimension(D)),&#xd;
    array_type(TYPE2, array_of(AO2), dimension(D)),&#xd;
    similar_type(AO1,AO2).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    wildcard_type(TYPE1, bound(B1), is_upper_bound(IUB)),&#xd;
    wildcard_type(TYPE2, bound(B2), is_upper_bound(IUB)),&#xd;
    similar_type(B1,B2).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    (&#xd;
        primitive_type(TYPE1 , code(&apos;int&apos;)),&#xd;
        type(TYPE2 , name(&apos;Integer&apos;))&#xd;
    );&#xd;
    (&#xd;
        primitive_type(TYPE2 , code(&apos;int&apos;)),&#xd;
        type(TYPE1, name(&apos;Integer&apos;))&#xd;
    ).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    (&#xd;
        primitive_type(TYPE1 , code(&apos;double&apos;)),&#xd;
        type(TYPE2 , name(&apos;Double&apos;))&#xd;
    );&#xd;
    (&#xd;
        primitive_type(TYPE2 , code(&apos;double&apos;)),&#xd;
        type(TYPE1, name(&apos;Double&apos;))&#xd;
    ).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    (&#xd;
        primitive_type(TYPE1 , code(&apos;float&apos;)),&#xd;
        type(TYPE2 , name(&apos;Float&apos;))&#xd;
    );&#xd;
    (&#xd;
        primitive_type(TYPE2 , code(&apos;float&apos;)),&#xd;
        type(TYPE1, name(&apos;Float&apos;))&#xd;
    ).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    (&#xd;
        primitive_type(TYPE1 , code(&apos;long&apos;)),&#xd;
        type(TYPE2 , name(&apos;Long&apos;))&#xd;
    );&#xd;
    (&#xd;
        primitive_type(TYPE2 , code(&apos;long&apos;)),&#xd;
        type(TYPE1, name(&apos;Long&apos;))&#xd;
    ).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    (&#xd;
        primitive_type(TYPE1 , code(&apos;short&apos;)),&#xd;
        type(TYPE2 , name(&apos;Short&apos;))&#xd;
    );&#xd;
    (&#xd;
        primitive_type(TYPE2 , code(&apos;short&apos;)),&#xd;
        type(TYPE1, name(&apos;Short&apos;))&#xd;
    ).&#xd;
&#xd;
similar_type(TYPE1,TYPE2):-&#xd;
    (&#xd;
        primitive_type(TYPE1 , code(&apos;char&apos;)),&#xd;
        type(TYPE2 , name(&apos;Character&apos;))&#xd;
    );&#xd;
    (&#xd;
        primitive_type(TYPE2 , code(&apos;char&apos;)),&#xd;
        type(TYPE1, name(&apos;Character&apos;))&#xd;
    ).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Use of variables and fields</title>
      <description>Check if a variable or a field is used</description>
      <predicates>/* Check if a variable (or a field) VAR is used in the method METHOD inside the class (or interface) CLASS */&#xd;
/* The predicate returns REF (which is the syntax structure that uses VAR) */&#xd;
/* METHOD and CLASS are optional parameters: if they are not specified, the predicate will instantiate them */&#xd;
&#xd;
var_reference(VAR,METHOD,CLASS,REF):-&#xd;
    (&#xd;
        array_access(REF, _, array(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        array_access(REF, _, _, index(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        array_creation(REF, _, _, _, initializer(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        array_initializer(REF, _, expressions(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        assert_statement(REF, _, expression(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        assert_statement(REF, _, _, message(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        assignment(REF, _, _, left_operand(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        assignment(REF, _, _, _, right_operand(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        cast_expression(REF, _, _, expression(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        catch_clause(REF, _, exception(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        class_instance_creation(REF, _, _, _, arguments(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        conditional_expression(REF, _, condition(VAR), _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        conditional_expression(REF, _, _, then(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        conditional_expression(REF, _, _, else(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        constructor_invocation(REF, _, _, arguments(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        creation_reference(REF, _, _, _, arguments(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        do_statement(REF, _, expression(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        enhanced_for_statement(REF, _, parameter(VAR), _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        enhanced_for_statement(REF, _, _, expression(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        expression_method_reference(REF, _, expression(VAR), _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        expression_method_reference(REF, _, _, _, arguments(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        field_access(REF, _, expression(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        field_access(REF, _, _, field(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        for_statement(REF, _, _, expression(VAR), _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        if_statement(REF, _, condition(VAR), _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        infix_expression(REF, _, _, left_operand(VAR), _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        infix_expression(REF, _, _, _, right_operand(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        infix_expression(REF, _, _, _, _, extended_operands(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        instanceof_expression(REF, _, expression(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        lambda_expression(REF, _, parameters(LIST), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        method_declaration(METHOD, parent(CLASS), _, _, parameters(LIST), _, _, _, _, _, _);&#xd;
        constructor_declaration(METHOD, parent(CLASS), _, _, parameters(LIST), _, _, _, _, _, _);&#xd;
        method_invocation(REF, _, expression(VAR), _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        method_invocation(REF, _, _, _, arguments(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        postfix_expression(REF, _, _, operand(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        prefix_expression(REF, _, _, operand(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        qualified_name(REF, _, qualified(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        qualified_name(REF, _, _, name(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        return_statement(REF, _, expression(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        super_constructor_invocation(REF, _, expression(VAR), _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        super_constructor_invocation(REF, _, _, _, arguments(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        super_field_access(REF, _, field(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        super_method_invocation(REF, _, _, arguments(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        super_method_reference(REF, _, _, arguments(LIST), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        switch_case(REF, _, case(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        switch_statement(REF, _, switch(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        synchronized_statement(REF, _, synchronized(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        this_expression(REF, _, expression(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        throw_statement(REF, _, throw(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        try_statement(REF, _, resources(LIST), _, _, _, body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        type_method_reference(REF, _, _, _, arguments(LIST), body_declarations(METHOD), type_declaration(CLASS), _);&#xd;
        variable_declaration(REF, _, _, _, _, _, initializer(VAR), body_declaration(METHOD), type_declaration(CLASS), _);&#xd;
        while_statement(REF, _, condition(VAR), _, body_declaration(METHOD), type_declaration(CLASS), _)&#xd;
    ),&#xd;
    (&#xd;
        var(LIST);&#xd;
        (&#xd;
            nonvar(LIST),&#xd;
            member(VAR,LIST)&#xd;
        )&#xd;
    ).</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Allowed constants</title>
      <description>Specify constants allowed in code</description>
      <predicates>/* Allowed constants */&#xd;
/* Constants usually are related to object-oriented errors */&#xd;
/* The allowed constants are constants commonly used that rarely are related to errors */&#xd;
/* Add constants here if you want the plugin to do not alert you when students use them */&#xd;
&#xd;
valid_literal(&apos;0&apos;):- !.&#xd;
valid_literal(&apos;0f&apos;):- !.&#xd;
valid_literal(&apos;0.0&apos;):- !.&#xd;
valid_literal(&apos;1&apos;):- !.&#xd;
valid_literal(&apos;1.0&apos;):- !.&#xd;
valid_literal(&apos;1f&apos;):- !.&#xd;
valid_literal(&apos;&quot;&quot;&apos;):- !.&#xd;
valid_literal(&apos;&quot; &quot;&apos;):- !.</predicates>
    </simple-predicate>
    <simple-predicate>
      <title>Classes (auxiliary)</title>
      <description>Auxiliary predicates that focus on classes</description>
      <predicates>/* Check if a class is too long (i.e if the class has too much public behavior methods) */&#xd;
/* This predicated is defined with 15 as minimun number of public behaviors needed to be a long class */&#xd;
&#xd;
long_class(ID):-&#xd;
    class_declaration(ID, _, _, _, _, _, _, _, methods(METHODS), _, _),&#xd;
    filter_behaviours(METHODS,BEHAVIOURS),&#xd;
    filter_methods(METHODS,JUST_METHODS),&#xd;
    filter_public_methods(JUST_METHODS,PUBLIC_METHODS),&#xd;
    filter_behaviours(PUBLIC_METHODS,BEHAVIOURS),&#xd;
    LENGTH &gt; 15. &#xd;
&#xd;
/* Check if a class is too short (i.e if the class has very few public behavior methods) */&#xd;
/* This predicated is defined with 3 as maximum number of public behaviors needed to be a long class */&#xd;
&#xd;
short_class(ID):- &#xd;
    class_declaration(ID, _, _, _, _, _, _, _, methods(METHODS), _, _),&#xd;
    filter_methods(METHODS,JUST_METHODS),&#xd;
    filter_public_methods(JUST_METHODS,PUBLIC_METHODS),&#xd;
    filter_behaviours(PUBLIC_METHODS,BEHAVIOURS),&#xd;
    length(BEHAVIOURS,LENGTH),&#xd;
    LENGTH &lt; 3.</predicates>
    </simple-predicate>
  </predicates>
</predicates-set>